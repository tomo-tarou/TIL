## Linuxとは
- Linuxは、本来Linux系OSの核であるLinuxカーネルを指す言葉である。カーネルとはOSの中核を担うプログラムであり、ハードウェアの資源管理やソフトウェアとハードウェアを繋ぐ役割を担う。
- カーネルがソフトウェアとハードウェアの橋渡しとなることでカーネルがソフトウェアの利用に合わせてハードウェアに命令を出すことができ、これによりソフトウェアは直接ハードウェアに対して命令をしなくてもすむようになっている。
- カーネルはOS(コンピュータを制御するソフトウェア)の核である一方でカーネル単体ではOSを動作させることは出来ない。OSを動かすためにはカーネル以外にもさまざまなソフトウェアが必要。そして、Linuxカーネルとその他のソフトウェアを組み合わせたものがLinuxディストリビューションであり広い意味でのLinuxになります。
- Linuxディストリビューションは大きく分けてDebian系、Red Hat系、Slackware系の三つが存在する。そして、これら三つの系統からさらに派生版が生まれており、三つの系統以外にも独立した系統のディストリビューションも存在している。

[Linuxのディストリビューションについて（ubuntu, centos）](https://envader.plus/article/7)

### **ディレクトリにまつわる用語**

| 用語 | 説明 |
| --- | --- |
| ディレクトリ | Linuxにおけるフォルダのこと |
| カレントディレクトリ | 今自分がいるディレクトリ |
| ルートディレクトリ | 一番上の階層のディレクトリ |
| ホームディレクトリ | ユーザーがログインした時に最初に開くディレクトリ |

パス(path)とは**ファイルのある場所までの道のり** を表すものです。“path”は「道・道のり・経路」といった意味がある英単語

| 記号 | 説明 |
| --- | --- |
| . | カレントディレクトリ(現在いるディレクトリのことです) |
| .. | 一つ上の階層(ディレクトリ) |
| / | ルートディレクトリ |
| ~ | ホームディレクトリ |
| - | ひとつ前にいたディレクトリ |

絶対パスは、**`/`(ルートディレクトリ)を起点にした、ファイルの場所を示すパス** 。

（絶対パスを「フルパス(full path)」ということもある。）

## cdコマンド
cd （change directoryの略）はディレクトリ間を移動する際に使用するコマンド。現在作業をしているディレクトリ（カレントディレクトリ）から、別のディレクトリに移動するときに使用。
**-（ハイフン）** を指定すると一つ前にいたディレクトリに移動することができる。

## lsコマンド
ls（listの略だが、list segmentsの略説もある）はディレクトリの中にあるファイルやディレクトリ等を確認するために使用するコマンド

### 主なオプション
| -a | 隠しファイルを含む全てのファイル(ディレクトリ)を表示する |
| --- | --- |
| -A | 隠しファイルを含む全てのファイル(ディレクトリ)のファイル名のみを表示する |
| -l | ファイルの種類や所有者・所有グループなどのファイル(ディレクトリ)の詳細を表示する |
| -i | inode番号も表示する |

### inode番号とは

### **`i` オプション**

- **`i`** オプションは、**`ls`**コマンド実行時に各ファイルやディレクトリのinode番号も一緒に表示するオプションです。
- **inode番号**:
    - inode番号は、LinuxやUnix系オペレーティングシステムにおいて、ファイルシステムが各ファイルやディレクトリを識別するために使用するユニークな番号
    - inodeにはファイルのメタデータ（サイズ、作成日時、所有者、パーミッションなど）が保存されているが、ファイル名やディレクトリ名は含まれない。
- 使用シーン（シチュエーション）
    1. **ファイルシステムのトラブルシューティング**:
        - inode番号を使って、ファイルシステムの問題を診断する際に役立つ。特にファイルシステムの破損やエラーが疑われる時に、inode番号を調べることで問題の原因を特定しやすくなる
    2. **ハードリンクの確認**:
        - 同じinode番号を持つ複数のファイル名（ハードリンク）が存在する場合、**`ls -i`**を使用してそれらが同じファイルを指しているかどうかを確認できる
    3. **ファイルの重複検出**:
        - 大量のファイルがある場合、**`ls -i`** コマンドを使用してinode番号を確認し、同じinode番号を持つファイルが重複していないかチェックできる
    4. **バックアップや復元プロセス**:
        - ファイルシステムのバックアップや復元を行う際、inode番号を参照して正しいファイルがバックアップや復元されているかを確認するのに役立ちます。
    
    これらの用途は、主にシステム管理者やアドバンスドユーザーがファイルシステムの深いレベルで作業を行う際に特に重要になりますにゃん。通常の日々の使用ではあまり使われることはないかもしれませんが、特定の状況や問題解決には非常に役立つコマンド
    

### ハードリンクとは
- ハードリンクは、ファイルシステム上の同じデータを指す異なるファイル名である。これらはすべて同じinode番号を共有する
- これにより、複数のファイル名が実際には同じ物理的なデータを指していることになる
- ハードリンクを作成すると、異なる名前で同じファイルにアクセスできますが、ディスク上のスペースは追加で消費されない
- いずれかのハードリンクを変更または削除しても、他のハードリンクや元のファイルには影響しない。ファイルシステムは最後のリンクが削除されるまでデータを保持します。

**例：**ファイル **`file1.txt`** があり、それに **`file2.txt`** というハードリンクを作成した場合、**`file1.txt`** と **`file2.txt`** は同じinode番号を持ち、どちらも同じファイルの内容を指す。この特性は、ファイルの整理、バックアップ、データ管理などで役立つが、同時に複数のファイル名が同じ内容を指していることを認識しておく必要がある

### **ハードリンクの特性**
- **同じinode番号**: ハードリンクされたファイルは、同じinode番号を持つ。これは、同じ物理的なデータを指していることを意味する。
- **異なるファイル名**: 同じファイル内容が異なる名前で存在することができるが、これらはファイルシステム上では同一のファイルとして扱われる。

### **ハードリンクでない場合**
- 異なるinode番号を持つファイルは、ハードリンクではない。これらは別々のファイルとして存在し、それぞれ独立した内容を持つ。
- 例えば、ファイルをコピーして新しい名前を付けた場合、コピーされたファイルは新しいinode番号を持ち、元のファイルとは異なるものになる。

ハードリンクは同じデータを指す複数のエントリを作成するためのメカニズムだが、単にファイル名が異なるだけではハードリンクとは言えない。ハードリンクかどうかはinode番号によって判断される。

## catコマンド
catはファイルの中身を見るコマンドで、「concatenate」（つなげる・連結する）の略

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -s | 連続したスペースやタブを1行にして表示する |
| -n | 行番号をつけて表示する |
| -A | 非表示文字も含めてすべて表示する |
| -E | 最終行に$を表示する |

```
# sample1.txtとsample2.txtの中身を連結して表示します。
cat sample1.txt sample2.txt

# sample1.txtとsample2.txtの中身を連結させたものをsample3.txtという新規ファイルに出力します。
cat sample1.txt sample2.txt > sample3.txt
```

ファイルの中身を逆順で表示する**`tac`**というコマンドもある

```
# sample.txtというテキストファイルを作成します。
vi sample.txt
==========
Google
Apple
Facebook
Amazon
==========

# tacコマンドでsample.txtを出力します。
tac sample.txt
Amazon
Facebook
Apple
Google
```

## nlコマンド
nl(number line)は行頭に行番号を振って出力するコマンド。

```bash
nl sample.txt
	1 Google
	2 Apple
	3 Facebook
	4 Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -b | 指定されたタイプで行番号を振る |
| -h | -bと同様の指定したタイプでヘッダ(header)に行番号を振る |
| -f | -bと同様の指定したタイプでフッタ(footer)に行番号を振る |

### **タイプ**

オプションにはタイプを指定できます。

| タイプ | 説明 |
| --- | --- |
| a | すべての行 |
| t | 空行でないすべての行 |
| p | 正規表現にマッチしたテキストを含む行 |

## fmtコマンド
fmt(format)はファイルを整形して出力するコマンド

```bash
# オプションのない場合は全て横並びになります。
fmt sample.txt
Google Apple Facebook Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -c | インデントを保持したまま整形する |
| -s | 長い行を複数行に分割する |
| -t | タグ(a.や 1.など)付きの段落として整形する |
| -w | 表示幅を指定する |

## wcコマンド
wc(word count)は文字数をカウントしたり、ファイルサイズを出力したりするためのコマンド

```
wc test_file
15      15     105 test_file
```

オプションなしの場合は[行数]・[単語数]・[文字数]・[ファイル名]という順序で表示されます。

### **主なオプション**
| オプション | 説明 |
| --- | --- |
| -c | バイト数を表示する |
| -m | 文字数を表示する |
| -l | 改行数を表示する |
| -w | 単語数を表示する |
| -L | 最長の行を表示する |

## cutコマンド
cutはファイル内のテキストを部分的に切り取って出力するためのコマンド

```bash
# stationery.txtというファイルを作成します。
vi stationery.txt
=========
pencil
stapler
paper clip
eraser
=========

# 区切り文字にスペースを指定し、1つ目の項目のみを表示します。
# 3行目は”paper”だけが出力されます。
cut -d " " -f 1 stationery.txt
pencil
stapler
paper
eraser
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -b | 切り取るバイト数を指定する |
| -c | 指定列の文字のみを切り出す |
| -d | 区切り文字(delimiter)を指定する (デフォルトではカンマです) |
| -f | 区切られた項目のうち、表示する項目を指定する |

## prコマンド

pr(print)は印刷に適した形式にファイルを整形するコマンド

```bash
pr -2 sample.txt
Google				    Facebook
Apple				    Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -d | 行間に空行を差し込む |
| -数値 | 指定した数値の列数に整形する |

## mvコマンド

mvはディレクトリやファイルを別のディレクトリへ移動したり、ディレクトリ名やファイル名を変更する際に使用するコマンド

```bash
# 使い方
mv [オプション] [移動させたいディレクトリ(またはファイル)名] [移動先のディレクトリ名]
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -f | 移動先に同名のファイルがある場合、強制的に移動（上書き）されます。 |
| -i | 移動先に同名のファイルがある場合、確認メッセージが表示されます。 |
| -b | 移動により上書き（削除）されるファイルのバックアップを作成します。 |
| -n | 移動先に同名のディレクトリ（またはファイル）がある場合は、処理を実行しません。 |
| -v | 移動処理を行う際の詳細情報を表示します。 |

mvコマンドはディレクトリやファイルの中身は変更せず、名前だけを変更することもできる。 その際、新しく指定するディレクトリ名(またはファイル名)は、そのディレクトリに存在しない名前でなければならない。既存の名前を指定してしまうと、そのディレクトリやファイルが対象ディレクトリ・ファイルの内容で上書きされてしまうので注意が必要。

```bash

# ファイル名をファイル1からファイル2へ変更します。
mv [ファイル1] [ファイル2]
```

ファイルを任意のディレクトリに移動する場合には、移動先のディレクトリ名の後ろに/.をつけることで、より安全に作業を行える。この/.の指定により、移動先がディレクトリであることを明示的に示すことができ、存在しないディレクトリ名が指定された場合に、予期しないリネーム操作を防ぐことができる。 この/.には「ディレクトリ直下の」という意味があります。もし/.を付けずに上記のコマンドを指示し、且つhogehogeディレクトリが存在していなかった場合、hoge.txtファイルはhogehogeというファイルにリネームされるという挙動をとる。

```bash

#hoge.txtをhogehogeディレクトリに移動
mv hoge.txt hogehoge/.
```

## cpコマンド
cpは既存のファイルを複製する（コピー）際に使用するコマンド

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -i | コピーによって上書きされるファイルがある場合、確認メッセージを表示 |
| -v | コピーの実行内容を表示 |
| -n | コピー先に既に同名のファイルが存在する場合、処理を中断する。 |
| -f | コピー先に同名のファイルが存在していても、強制的にコピー（上書き）を実行。 |
| -b | コピー（上書き）時にバックアップファイルが作成される |
| -r | ディレクトリ内を再帰的にコピーする。 |
| -p | 所有者・属性・更新日時など元ファイルのものを保持する。 |

### **再帰的にコピーする**

- -rオプションを使用してディレクトリをコピーすると、その中にある全ての子ディレクトリやファイルを含めてコピーすることが出来ます。

```bash

cp -r [コピー元ディレクトリ] [コピー先ディレクトリ]
```

- 「再帰的」は、ある条件が満たされた場合に、その処理が自分自身を呼び出し繰り返すことを指す。cpコマンドの場合、-rオプションを使用すると、指定したディレクトリ内のすべてのサブディレクトリやファイルをコピーすることが可能になる。このとき、コピー処理は各ディレクトリやファイルに対して一つずつ実行され、それぞれの処理が終わるごとに、次に処理対象となる要素がコピー対象であるかどうかを判断する。コピー対象であると判断された場合、処理は再度自分自身を呼び出し、これを繰り返すことで全ての要素をコピーする。このような処理のことを「再帰的」と言う。

- cp: -r not specified; omitting directory 'myapp/'

- ディレクトリをコピーする際に -r をつけ忘れたことによるエラー
  - specify 指定する
  - ommit 省略

[Linuxコマンド [cd/ls/cat等]](https://envader.plus/course/1/scenario/1001)

## touchコマンド

touchとは、空のファイルを新規作成したり、ファイルのタイムスタンプを更新したりするためのコマンド。タイムスタンプとは、ファイルの**最終更新日**を表すもの。

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -t | [[CC]YY]MMDDhhmm[.ss]の書式に則り、タイムスタンプを指定した日時に更新 |
| -d | 日時を文字列で指定して、タイムスタンプを更新 |
| -c | 存在しないファイル名を指定しても、空の新規ファイルを作成しない |
| -r | 指定した他のファイルのタイムスタンプに合わせて更新される |
| -m | ctimeのみを変更される |

-tオプションでは、過去の時間も指定できる

-mオプションで変更されるctimeとは、inode変更日時のことを指す

それに対して、何も指定しない場合は、最終更新日時(mtime)と最終アクセス日時(atime)が更新される。

c**は "change"（変更）の略で、ファイルのメタデータやinode情報が最後に変更された日時を指す「ctime」を表している。**

m **は "modification"（変更）の略で、ファイルの内容が最後に変更された日時を指す「mtime」を表している。**

a **は "access"（アクセス）の略で、ファイルが最後に読まれた日時を指す「atime」を表している。**

## fileコマンド

ファイルの種類を識別するときに使うコマンド。

ファイル名を見ただけではテキストファイルなのかバイナリファイルなのか判断できないが、fileコマンドを使用することでファイルの中身を調べることができる。

- ファイルの種類
    
    コンピュータでは、テキストファイル・画像ファイル・音声ファイルなど色々な種類のファイルを扱うが、これらは大きく2種類に分けることができる。
    
    - **テキストファイル：中身を開いたときに文字だけで構成されるファイル**
    - **バイナリファイル：テキストファイル以外の人間が読むことのできないファイル**
    
    **拡張子とファイルシグネチャの違い**
    
    - ファイル中身を判断するものとして、拡張子（.txt）と**ファイルシグネチャがある。**
    - 拡張子は、お馴染みのようにファイルの種類を識別するためにファイル名の後につけられたドットから始まる文字列のこと。例えば、「hogehoge.txt」というファイルの場合、「**.txt**」がテキストファイルを表す拡張子になる。
    - 拡張子はOSが、拡張子をもとに起動するプログラムを変更したり、人間が一目見てファイルの種類を識別するために付けられる。つまり、拡張子はファイルの種類を人間や起動するアプリケーションが判定するためのものであり、実際のファイルの中身とは別物である。そこで、ファイルシグネチャが存在する。
    - ファイルシグネチャとは、各ファイルの先頭数バイトの決められた文字列のこと。ファイルフォーマット・マジックナンバーと呼ぶこともある。OSは、ファイルの先頭数バイトを確認することにより（実際の）ファイルの種類を判別する。
    

### **基本的な使い方**

```bash
file ファイル名

# 例
file test.txt
test.txt: Unicode text, UTF-8 text, with no line terminators

file sample.jpeg
sample.jpeg: JPEG image data, Exif standard: [TIFF image data, big-endian, direntries=6, orientation=upper-left, xresolution=86, yresolution=94, resolutionunit=2], baseline, precision 8, 4032x3024, components 3
```

fileコマンドではファイルの内容をテストし、ファイルの種類を特定している。

テスト結果から下記いずれかの内容を表示する。

- **text：テキストファイル**
- **executable：実行可能ファイル**
- **data：それ以外のファイル（通常はバイナリファイル、または表示不能なファイル）**

### **複数のファイルを同時に指定する**

fileコマンドの後に複数のファイルを同時に指定することもできる。

```bash
file ファイル名1 ファイル名2

# 例
file test.txt index.html
test.txt:   Unicode text, UTF-8 text, with no line terminators
index.html: HTML document text, ASCII text
```

### **圧縮されているファイルを調べる**

「-**z**」オプションで、圧縮されているファイルの元の形式を調べることができる。

```bash
file -z ファイル名

# 例1：「-z」オプションがない場合（ファイル形式がわからない）
file test.txt.gz
test.txt.gz: gzip compressed data, was "test.txt", last modified: Sat Jan  8 00:36:35 2022, from Unix, truncated

# 例2：「-z」オプションがある場合（テキストファイルとわかる）
file -z test.txt.gz
test.txt.gz: Unicode text, UTF-8 text, with no line terminators (gzip compressed data, was "test.txt", last modified: Sat Jan  8 00:36:35 2022, from Unix)

```

### **主なオプション**

| オプション | 意味 |
| --- | --- |
| -b | 出力行の最初にファイル名を表示しない（簡易モード） |
| -f | 調べるファイルの一覧を指定する |
| -L | シンボリックリンクの参照先を調べる |
| -N | 出力を整列するためのファイル名への空白の追加を行わない |
| -n | １つのファイルをチェックするごとに標準出力に出力する |

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2725%27%20height=%2725%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2725%27%20height=%2725%27/%3e)

[Linuxコマンド [cd/ls/cat等]](https://envader.plus/course/1/scenario/1001)

[Linuxコマンド [touch編]](https://envader.plus/course/1/scenario/1005)

[Linuxコマンド [file編]](https://envader.plus/course/1/scenario/1046)

[代表的な拡張子の一覧【とはサーチ】](https://www.toha-search.com/pc/kakutyousi-list.htm)

## プロセスとは

プロセスとは、メモリ上にある実行中のひとつひとつのプログラムのこと。プロセスはコンピュータリソースを消費する。ここでいうコンピュータリソースとは、CPUやメモリなどを指す。限られたリソースをどのように配分するのかは非常に重要なことである。そこでプロセス管理が必要になってくる。

### **プロセスの状態**

プロセスには、さまざまな”状態”があります。

| 状態 | 説明 |
| --- | --- |
| 生成(開始) | 新たにプロセスが生成された状態 |
| 実行可能 | CPUが割り当てられるのを待っている状態 / ※ 実行中のプロセスが他のプロセスに割り込まれた時もこの状態になる |
| 実行中 | プロセスにCPUを割り当てられた状態 |
| 待機 | プロセスの読み書き処理待ち状態 / ※ このときCPUの処理は必要なく、読み書きが終わると実行可能状態になる |
| 終了 | プロセスの処理が完了、あるいは中止した状態 |

## **プロセスのジョブ**

ジョブとはひとつ以上のプログラムの実行単位のこと。**コマンドを入力して実行**するとひとつのジョブとしてカウントされるので、コマンドがひとつでもジョブになる。

ジョブには二種類存在する。

**フォアグラウンドジョブ：** シェルの画面内で実行される。普通にターミナルでコマンドを実行する場合フォアグラウンドジョブになる。表側で実行されるので処理の完了を待つ必要がある。

**バックグラウンドジョブ：** シェルの画面外で動作する。処理は実行されているが、ユーザーの操作対象ではない。裏側で実行されるので処理の完了を待つ必要がない。

バックグラウンドで実行

```bash
コマンド &
```

実行中のジョブを表示

```bash
jobs
```

バックグラウンドジョブをフォアグラウンドに戻したいとき

```bash
fg %ジョブID
```

フォアグラウンドジョブをバックグラウンドジョブにしたいとき

```bash
bg %ジョブID
```

## プロセスとジョブの違い

プロセスは、実行中のプログラムのインスタンス（実体のこと）で、オペレーティングシステムからメモリ空間、プロセスID、必要なリソースなどを割り当てられている。プロセスはシステムリソースを利用して、実際にタスクを実行する。

一方で、ジョブとは、ひとつまたは複数の関連するプロセスの集まりで、より大きなタスクや一連のタスクを実行するための単位。たとえば、ユーザーがある目的のために連続して実行するプログラム群をジョブと呼ぶ。

簡単に言うと、プロセスは個々の実行中のプログラムで、ジョブはそれらプロセスが集まって一つの目的を達成するための単位と考えると理解しやすい。例えば、印刷ジョブは複数のプロセス（データを処理するプロセス、プリンタに送信するプロセスなど）を含むことがある。

プロセスはシステムの動的な活動の基本単位で、ジョブはユーザーが指定したタスクの実行単位、という感じ

## killコマンド・psコマンド

killは、プロセスを終了させるためのコマンド

使用用途

- **時間のかかるコマンドを誤って実行してしまった**
- **ゾンビプロセス(実態はないのにプロセステーブルに存在するプロセス)に対処**

## **基本的な使い方**

psコマンドでプロセスIDを確認する

```bash
ps aux
```

プロセスIDとシグナルを指定して実行

```bash
kill シグナル番号 PID
```

コマンドを強制終了したい場合

```bash
kill -9 PID
```

### **シグナルについて**

プロセス間の通信をするための信号で、プロセスの状態を遷移することができる。

プロセスはスーパーユーザーからのシグナルを受け取ることができる。

[プロセス管理 ｰ 1](https://envader.plus/course/15/scenario/1008)

[プロセス管理 ｰ 2](https://envader.plus/course/15/scenario/1009)

## uname****コマンド****

カーネルやバージョンなどを確認するために使用するコマンド

### よく利用するオプション

unameコマンドのみではLinuxという情報以外何もわからないので、知りたい情報に合わせてオプションを指定します。今回はよく利用するオプションを紹介します。

| オプション | 説明 |
| --- | --- |
| -o | OSの名前を表示 |
| -v | カーネルのバージョンを表示 |
| -r | カーネルのリリース番号を表示 |
| -p | CPUの種類を表示 |
| -a | unameコマンドで確認できる全ての情報を表示 |

[バージョンの確認](https://envader.plus/course/15/scenario/1010)

## whichコマンド

whichは指定したコマンドのフルパスを表示してくれるコマンド

```bash
which ls
/bin/ls
```

/binに存在するlsコマンドが実行されていることが分かる。つまり、このフルパス（/bin/ls）を実行してもlsとだけ打って実行しても同じことであるということ。

また、コマンドがビルトインコマンドなのか、外部コマンドなのかも判定する。echoコマンドのパスを調べてみる。

```bash
which echo
echo: shell built-in command
```

「echoはシェルのビルトインコマンドです」と表示されている。

**ビルトインコマンド**とは、**シェルに組み込まれているコマンド**であるため、パスはない。それ以外のコマンドは**外部コマンド**といい、/binや/usr/binなどといったバイナリを格納するディレクトリに置かれている。

whichはファイルやパッケージの保存場所を調べるときなど、このあと紹介するtypeやwhereisに比べてかなり頻繁に使用する。

## typeコマンド

typeは、機能的にはほとんどwhichと同様

```bash
# findコマンドのフルパスを表示する
type find
find is /usr/bin/find
```

丁寧に「findのパスは/usr/bin/findです」と表示してくれるが、シンプルにパスのみを表示してくれるwhichの方がよく使われる。

## whereis****コマンド****

whereisはコマンドとその関連ファイルのフルパスを表示する。whichやtypeとの違いは、コマンドに関連するファイルのフルパスまで表示すること。ただし、あまり使用するケースは多くない。

```bash
whereis ls
ls: /usr/bin/ls /mnt/c/Program Files (x86)/Gow/bin/ls.exe /usr/share/man/man1/ls.1.gz
ユーザー名:~# whereis find
```

| オプション | 説明 |
| --- | --- |
| a | コマンドのエイリアス、フルパスを表示 |
| p | コマンドのフルパスを表示 |
| t | コマンドのエイリアスを表示 |

## コマンドサーチパスとは

コマンドサーチパス（PATH）は、シェルがコマンドの実行ファイルを探すために参照するディレクトリのリスト。これにより、ユーザーは実行ファイルのフルパスを指定せずにコマンドを実行できるようになる。実質的に、PATHはコマンドのショートカットを提供し、効率的にシステムを操作するために使われる**。**

- コマンドサーチパスを環境変数PATHに登録することを「パスを通す」と言う
- pathにコマンドのパスが登録されていることを「パスが通っている」と言う

## パスを通す

新たなパスを追加して他のディレクトリ上にあるコマンドを認識させること。

コマンドサーチパスを環境変数PATHに登録することを「パスを通す」と言う。環境変数PATHには複数のパスを登録可能。コマンドが実行されると環境変数PATHに登録されているディレクトリを順に検索し、コマンドが見つかれば実行する。パスが通っていないコマンドを実行するとエラーになる。

```bash
# 環境変数PATHを表示
echo $PATH
/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin

# export コマンドで新しくPATHを追加
export PATH=$PATH:/home/sample

# 環境変数PATHに/home/sampleが追加されている
echo $PATH
/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/home/sample

```

これで lsや cat のようにファイル名をコマンドラインで実行するだけで、/home/sample内のコマンドやシェルスクリプトを実行することができる。

### パスを通す時の注意点

- カレントディレクトリにはパスを通さない（セキュリティ的に問題が生じるため）
- カレントディレクトリのファイルを実行したい場合にはファイル名の先頭に./をつけて実行することになっている
- パスを通す際は安全なディレクトリに絞って設定することが大切

## ターミナルとパスの違い

ターミナルは、ユーザーがコマンドを入力し、システムと対話するためのインターフェイスを提供するアプリケーションのこと。昔の物理的な端末から派生した概念で、現在ではソフトウェアとして実装されたウィンドウやプログラムである。

シェルは、ユーザーからのコマンドを受け取り、それをオペレーティングシステムへと伝える役割を持つプログラム。シェルはコマンドラインインターフェイス（CLI）を提供し、ターミナルから入力されたコマンドに基づいて操作を行う。bashやzshなどが一般的なシェル。

要するに、ターミナルはコマンドを打つ場所であり、シェルはそのコマンドを解釈して実行するプログラムというわけである。両者は密接に連携していて、一般にはターミナルを開くとシェルが起動し、ユーザーのコマンド入力を待ち受ける状態になる。

## 実行ファイルとは

- 実行ファイルは、ほとんどの場合「バイナリファイル」のことを指す。（広義の解釈で、人間が読めるスクリプトファイル等も含み、それを実行可能なテキストファイルとすることもあるが、あまり一般的ではない。)
- 「バイナリファイル」はコンピュータが直接解釈し実行できる機械語の命令を含むファイル（0と1で構成されているので、人間は読む（解釈）できない）。Windowsでの .exe ファイルやLinuxでの実行可能なファイル（特定の権限が与えられたファイル）がこれに該当する。
- バイナリファイルの中でも多くのLinuxは実行ファイルの形式にELFというファイル形式のものを使用している。
- ELFとは、「Executable and Linkable Formats」の略で、主にUnix系のオペレーティングシステム（OS）で用いられる実行可能ファイル、オブジェクトファイル、共有ライブラリ、コアダンプのファイル形式のことを言う。多くのLinuxディストリビューションやUnix系OSでは、プログラムやライブラリなどのバイナリファイルの標準的な形式としてELFが採用されている。
- ELF形式は柔軟性があり、異なるプロセッサアーキテクチャやオペレーティングシステム間での移植性が高いため、幅広く利用されている。プログラムがコンパイルされると、その実行可能ファイルがELF形式で生成されることが多い。
- 実行権限の変更は、 **chmod** コマンドで行う
- **機械語**
    
    機械語は、コンピュータのプロセッサが直接理解できる命令セット。これはバイナリ形式（0と1の列）で表され、プロセッサによって直接実行される。
    
- **実行ファイルのプロセス**
    1. **読み込み**: 実行ファイル（バイナリファイル）は、記憶ディスクからコンピュータのメモリに読み込まれる。
    2. **解釈**: プロセッサは、実行ファイルの中のバイナリデータ（機械語命令）を読み取る。
    3. **実行**: プロセッサは読み取った命令を順番に実行。これにより、プログラムが動作する。
- **実行権限**
    
    実行ファイルには実行権限というものが存在する。実行権限とは、実行ファイルに対してすべてのユーザーが実行出来てしまうと、問題が発生するため設けられている。
    
    実行権限は パーミッションと呼ばれ、**ls -l** コマンドで確認することが可能。もしくは **ll** でも確認できる？
    
    ```bash
    ls -l
    total 1900
    -rwxr-xr-x 1 envader envader 1941911  9月 28 05:49 run1
    ```
    
- **パーミッションの確認方法**
    
    先頭に書いてあるこの **-rwxr-xr-x**文字は、
    
    先頭の一文字はファイルの種類を表示しています。
    
    | 種類 | 説明 |
    | --- | --- |
    | - | ファイル |
    | d | ディレクト |
    | l | シンボリック |
    
    -はファイルを表しています。
    
    dはディレクトリを表しています。
    
    lはシンボリックを表しています。
    
    | 種類 | 説明 |
    | --- | --- |
    | 2文字目から4文字目 | ファイルの所有者に対する権限 |
    | 5文字目から7文字目 | ファイルの所有グループに対する権限 |
    | l8文字目から10文字目 | その他に対する権限 |
    
    | 権限の種類 | 説明 |
    | --- | --- |
    | r | 読み取り権限 |
    | w | 書き込み権限 |
    | x | 実行権限 |
    
    ```jsx
    -rwxr-xr-x 1 envader envader 1941911  9月 28 05:49 run1
    ```
    
- 実行ファイルを実行するには？
    
    ```markup
    # 絶対パスを利用する場合
    (実行ファイルのパス)
    # 例
    /bin/ls
    /usr/bin/whoami
    ```
    
    ```markup
    # 現在いるディレクトリに目的の実行ファイルがある場合
    ./(ファイル名)
    # 例
    ./a.out
    ./main
    ```
    
- 実行ファイルを実行してみて何か問題がある時
    
    下記を疑ってみる
    
    - **ELFファイルなのか**
    - **実行権限は持っているのか**
    - **パスは適切か**

## chmodコマンド

実行権限の変更を行うコマンド

```bash
chmod 変更対象 変更方法 変更内容 対象ファイル
```

| 変更対象 | 説明 |
| --- | --- |
| u | ユーザー |
| g | グループ |
| o | その他 |
| a | 全員 |

| 変更方法 | 説明 |
| --- | --- |
| ＝ | 指定した権限のみを与える |
| ＋ | 指定した権限を追加する |
| ー | 指定した権限を剥奪する |

| 権限の種類 | 説明 |
| --- | --- |
| r | 読み取り権限 |
| w | 書き込み権限 |
| x | 実行権限 |

所有グループに書き込み権限を与えたい場合は

```bash
#run1は対象ファイル名を指す
chmod g+w run1
```

とすることで与えることができます。

複数指定することも可能です。

```bash
chmod o+rw run1
chmod go+w run1
```
## ユーザ管理について

Linuxでは1台のPCを複数のユーザーで利用する事が出来る。ユーザーには大きく3つの種類がある

| ユーザーの種類 | 説明 |
| --- | --- |
| 管理者 | rootユーザー、スーパーユーザーなどと呼ばれる。強力な権限を持っているため、ほとんどのコマンドを実行できる。 |
| 一般ユーザー | 限られた操作のみ実行できる。自分専用のディレクトリ内でファイルの追加や閲覧、変更などが可能。システムの変更などは出来ない。 |
| システムユーザー | 特殊なユーザー。特定のアプリケーションを実行する際に使用される。 |
- グループとは
    
    Linuxでは、ユーザーは必ず一つのグループに属する必要がある。それぞれのグループにディレクトリ、ファイルへの権限を付与することができる
    
    1. プライマリグループ
        
        ユーザーが最初に参照されるグループ。新規ユーザー作成の際にユーザー名と同じグループ名が作成される
        
    2. セカンダリグループ
        
        ユーザーを複数のグループに設定する場合はセカンダリグループに指定する
        

## **useraddコマンド**

- **useradd** は、新たにユーザーを追加する。
- ユーザーを追加できるのは、管理者ユーザーだけ。ユーザー名の訂正機能はないのでスペルミスしないよう注意が必要。
- useraddコマンドは、ユーザーを追加するだけでパスワードは設定できない。パスワードはpasswdコマンドで設定する。

### **基本的な使い方**

```bash
useradd [オプション] ユーザー名
※ []は省略可能

```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -m | ユーザーのホームディレクトリが存在しない場合、ユーザーと一緒に作成する。 |
| -D | デフォルト値の確認や変更を行うことができる。 |
| -g | ユーザー追加の際にプライマリグループを指定する |

## **usermodコマンド**

**usermod**(modify user)は、ユーザー情報を変更する。このコマンドはroot権限が必要。

ユーザー情報は、**vipw**コマンドを使用し**/etc/passwd**を編集し変更できますが、**usermod**コマンドを使用する方が一般的である。

※ なおテキストエディタ等でパスワードファイルを直接編集するのは、システムが正常に動作しなくなる恐れがあるため避けたほうがよい。

**オプション**

| オプション | 説明 |
| --- | --- |
| -c | コメントのフィールドを変更する |
| -d | ホームディレクトリを変更する |
| -g | プライマリグループを変更する。ユーザーは一つのプライマリグループにのみ所属できる |
| -G | セカンダリグループを変更する（置き換える）
既存のグループに加えて、新しいグループを追加する場合、-aをつけること。 |
| -s | ログインシェルを変更する |
| -L | パスワードをロックする |
| -U | パスワードロックを解除する |

```bash

touch testfile
ls -l testfile
-rw-r--r--  1 envader  envader  0  6  5 09:32 testfile

# ユーザー'envader'のプライマリグループを'redavne'に変更します
sudo usermod -g redavne envader
touch testfile_2
ls -l testfile_2
-rw-r--r--  1 envader  redavne  0  6  5 09:35 testfile_2

```

特定のアカウントのログインシェルを**/sbin/nologin**に設定すると、そのユーザーはログインしてシェルを利用することができなくなる。

```bash
# ユーザー'aderenv'をログインできないようにログインシェルを変更します。
usermod -s /sbin/nologin aderenv
```

## ****passwdコマンド****

- **passwd**は、パスワードを変更するためのコマンド
- 一般ユーザのパスワードは、管理者ユーザーにも分からない為パスワードを忘れたときは、管理者が新しいパスワードを作り直して知らせる必要あり
- pwgenコマンドを使うと、ランダムなパスワードを自動的に生成できる（yumコマンドでインストール可能）

### **基本的な使い方**

```bash
#管理者の場合
passwd [オプション] ユーザー名
※ []は省略可能

#一般ユーザーの場合
passwd
```

### **主なオプション(管理者権限が必要)**

| オプション | 説明 |
| --- | --- |
| -l | 指定したユーザーをロックする。 |
| -u | 指定したユーザーのロックを解除する。 |
| -S | パスワードの状態を表示する。 |
| -d | パスワードを削除する。 |
| -i | パスワードエージングを設定する |

### **使用例**

```bash
passwd
Old Password: #現在使用しているパスワードを入力します。
New Password: #新たに設定したいパスワードを入力します。
Retype New Password: #確認のため、新たなパスワードを再度入力します。
```

パスワードは入力しても画面には表示されないが、きちんと入力されている。

**passwd**コマンドは一般ユーザー(一般ユーザー権限)では、自身のパスワード以外は変更できない。rootを含むその他のユーザーのパスワードの変更にはroot権限が必要。

他のユーザーのパスワード変更には、以下のようにユーザー名を指定する。

```bash
# ユーザー'Ken'のパスワードを変更します。
sudo passwd tifa
```

### **/etc/passwd**

現在設定されている自身のパスワードを確認には、**/etc/passwd**ファイルを確認する。このファイルにはユーザー情報が書かれており、ユーザー名の後にパスワードが記載されている。

**各フィールド**

| フィールド | 説明 |
| --- | --- |
| ユーザー名 | ※ 省略 |
| パスワード | ※ 省略 |
| UID | ユーザーID |
| GID | グループID |
| GECOS(コメント) | その他ユーザー情報 |
| ホームディレクトリ | ユーザーのホームディレクトリ |
| ログインシェル | ログイン後に使用するシェル |

実際にどのような表記なのか見てみます。

```bash
# rootユーザーの例
root:x:0:0:root:/root:/bin/bash
envader:x:1000:1000:,,,:/home/yusuke:/usr/bin/zsh
```

現在のほとんどのシステムでは**シャドウパスワード**が使われており、パスワードのフィールドは**x**となっている。

### **シャドウパスワード**

**/etc/passwd**にはパスワードを**x**と表記し、実際には**/etc/shadow**ファイルに暗号化されたパスワードが記載される。

**/etc/shadow** は、root以外のユーザーはアクセス権限がないため、閲覧するにはroot権限が必要。

**各フィールド**

| フィールド | 説明 |
| --- | --- |
| ユーザー名 | ※ 省略 |
| パスワード | ※ 省略 |
| パスワードの最後の更新日 | 最も直近でパスワードを更新した日 |
| パスワードを変更する間隔の最低日数 | パスワードを定期的に変更する際の、その間隔の日数 |
| パスワードの有効期限 | パスワードエージング |
| パスワードの有効期限切れを何日前から通知するか | ※ 省略 |
| ログインしない場合のアカウント有効期限 | ※ 省略 |
| アカウントの有効期限 | ※ 省略 |
| フラグ | 現在は未使用 |

実際には以下のようにユーザー情報が記載されています。

```bash
sudo cat /etc/shadow
root:*:18375:0:99999:7:::
envader:$6$9YgzMkIXKldUPCFG$U.UYxyZhubItWX6868qFTeaT56XPLAGhsW./CLdPlD6Gwa/XBBklDF7HlmqofSFKl/xuwez0n72osgvfU0vxP0:18916:0:99999:7:::
```

rootのパスワードが未設定の際は*****で表記される。

パスワードの有効期限が設定されていない場合には、「パスワードの有効期限」フィールドに **99999** と表記される。

上の例では、rootも一般ユーザーも「ログインしない場合のアカウント有効期限」「アカウントの有効期限」「フラグ」が未設定であるため、**:::**となっている。

パスワードのフィールドの先頭に**!!**をつけると、アカウントをロックして、一定期間そのアカウントのログインを拒否できる。

### **/etc/nologin**

一般ユーザーのログインが不要で、一般ユーザーのログインを拒否したい場合は、**/etc/nologin**ファイルを作成する。一般ユーザーがログインしようとした際は、このファイルに記載された内容を表示し、ログインを拒否できる。

## ****groupaddとgroupdel****

- **groupadd**、**groupdel**コマンドはグループの新規作成、削除を行う
- **useradd**、**userdel**同様にルートユーザで実行する必要があり、**groupadd/groupdel グループ名で**作成する

### **/etc/group**

**/etc/group**でグループ一覧情報を管理しています。

```bash
root@b19fcbe36a3f:/# cat /etc/group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:
tty:x:5:
<省略>
envadergroup:x:1004:envaderuser　# ←これ
```

### **各フィールド**

| フィールド | 説明 |
| --- | --- |
| グループ名 | ※ 省略 |
| パスワード | ※ 省略 |
| GID | グループID |
| メンバー | グループに属しているメンバーリスト |

### **グループの新規作成、削除**

```bash
# groupadd newgroup グループの新規作成
# groupdel newgroup グループの削除
```

### **新規作成したグループの確認**

groupaddで新規作成したグループは**/etc/group**に保存される

```bash
cat /etc/group
<省略>
newgroup:x:1002:  新たにnewgroupが作成されている
```

グループの情報は、/etc/groupの最終行に開催されているので、以下のコマンドで確認できる

```bash
tail -1 /etc/group
```

### **ユーザーをグループに追加する**

作成したグループにユーザーを追加する際は、**root**ユーザーで**gpasswd -a ユーザー名 グループ名**とする。

```bash
# gpasswd -a envaderuser newgroup  newgroup(グループ名)にenvaderuser(ユーザー名)を追加
```

## usermodコマンドとの違い

```bash
usermod -a -G グループ名 ユーザー名
# 指定されたユーザーを指定されたグループに追加する
# -a オプションを使うことで、既存のグループに新しいグループを追加できる。
# -G オプションだけだと、ユーザーのセカンダリグループのリストが置き換わってしまう、-a オプションが重要
```

**gpasswd -a** コマンドと **usermod -a -G** コマンドは基本的に同じ働きをする。どちらもユーザーを既存のグループリストに保持しつつ新しいグループに追加する。ただし、usermodコマンドはユーザーの他の情報も変更出来るようなより包括的なコマンドで、gpasswdはグループメンバーシップに特化したコマンドである。

- どちらが一般的か
    
    どちらのコマンドも一般的に使われているにゃんが、使用状況によって異なる
    
    - シンプルにグループメンバーシップだけを変更したい場合は、**gpasswd -a** を使用することが多い
    - ユーザーの他の属性も同時に管理したい場合や、より広範なユーザー管理が必要な場合は、**usermod -a -G** を使用することが多い

## ****groupmodコマンド****

groupmodは、グループ名やグループIDなどを変更する。**groupmod オプション グループ名**のようにオプションと合わせて使用。

### **グループ名の変更**

```bash
# groupmod -n 新しいグループ名 既存のグループ名
# groupmod -n newenvadergroup newgroup
```

### **groupmod主なオプション**

| オプション | 説明 |
| --- | --- |
| -n グループ名 | 指定したグループ名に変更する |
| -g グループID | 指定したグループIDに変更する |
| -o | グループIDの重複を許す |

## **id**

idはユーザーIDと名前、属するグループのIDと名前を表示することができる。**id**と入力すると実行したユーザーの情報を取得し、**id ユーザー名**とすると指定したユーザー情報を取得することができる。

```bash
root# id　　ルートユーザーでidコマンドを実行
uid=0(root) gid=0(root) groups=0(root)

# id envaderuser　　envaderuserの情報を取得
uid=1001(envaderuser) gid=1001(envaderuser) groups=1001(envaderuser),1004(envadergroup)
```

### **idコマンドの出力**

| 項目 | 説明 |
| --- | --- |
| uid(user ID) | ユーザー番号(ユーザー名) |
| gid(group ID) | グループ番号(プライマリグループ) |
| groups | プライマリグループを含めた属しているグループの番号、グループ名 |

### **idコマンドの主なオプション**

| オプション | 説明 |
| --- | --- |
| -g | グループIDのみ表示 |
| -G | 所属しているすべてのグループIDを表示 |
| -n | IDの代わりにユーザー名やグループ名を表示 |
| -u | ユーザーIDのみを表示 |

## **getentコマンド**

- リーリエ解説
    
    > **getentコマンド**
    > 
    > 
    > **getent** コマンドは、システムの様々なデータベースから情報を取得するためのコマンドにゃん。これにはパスワード、グループ、ホスト名などの情報が含まれるにゃん。
    > 
    > ### **/etc/nsswitch.conf**
    > 
    > - **/etc/nsswitch.conf** は、システムがユーザーやグループ情報をどこから取得するかを定義しているファイルにゃん。
    > - このファイルでは、例えば、パスワード情報が **/etc/passwd** から、グループ情報が **/etc/group** から取得されるように定義されていることが多いにゃん。
    > 
    > ### **getentコマンドでの出力**
    > 
    > - **getent passwd** を実行すると、**/etc/passwd** ファイルの内容と同様の出力が得られるにゃん。これはシステム上の全ユーザーの情報を表示するにゃん。
    > - **getent group** を実行すると、**/etc/group** ファイルの内容と同様の出力が得られるにゃん。これはシステム上の全グループの情報を表示するにゃん。
    > 
    > ### **なぜこのような出力になるか**
    > 
    > - **/etc/nsswitch.conf** で指定されている設定により、**getent** コマンドは **/etc/passwd** や **/etc/group** などのファイルから情報を取得するにゃん。
    > - そのため、**getent** コマンドで得られる情報はこれらのファイルの内容と非常に似ているか、同じになるにゃん。

**getent**コマンドは**/etc/nsswitch.conf**ファイルに定義されているデータベースの内容を表示するコマンド。**/etc/nsswitch.conf**ではパスワードやグループに関するデータベースも定義されており、**getent**コマンドを使用することでこれらの内容を確認することができる。

以下のように**getent**コマンドを使用しユーザー情報、グループ情報を取得すると、それぞれ**/etc/passwd**、**/etc/group**と同様の出力がされる。

これは**/etc/nsswitch.conf**でpasswdデータベースは**/etc/passwd**、groupデータベースは**/etc/group**を参照するように定義されているためこのような出力になる

**ユーザー一覧**

```bash
# getent passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
<省略>
envaderuser:x:1001:1001::/home/envaderuser:/bin/sh
```

**グループ一覧**

```bash
# getent group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
<省略>
envaderuser:x:1001:
envadergroup:x:1004:envaderuser
```

## ****パスワードエージング****

パスワードエージング（password aging）とは、パスワードの有効期限を設定すること

### **chageコマンド**

**chage**（change age）は、パスワードエージング情報を設定・確認するためのコマンド

**オプション**

| オプション | 説明 |
| --- | --- |
| -l | パスワード・アカウントの有効期限を表示する |
| -m | パスワードを変更する間隔の最低日数を設定する |
| -M | パスワードの有効期限を設定する |
| -d | パスワードの最終更新日を設定する |
| -W | パスワードの有効期限切れを何日前から通知するかを設定する |
| -I | パスワード有効期限が切れた後に、アカウントがロックされるまでの期間を設定する |
| -E | アカウントが無効になる日付を設定する |

いくつかのオプションを使用して、ユーザー情報を変更する

```bash
# ユーザー'envader'に　「パスワードの変更間隔の最低日数を5日にする」、「パスワードの有効期限を30日間にする」という2つの条件を設定します。
chage -m 5 -M 30 envader
```

**chage**コマンド実行前と後で、**/etc/shadow**の内容がどのように変更されたのか確認

```bash
# Before
envader:$6$9YgzMkIXKldUPCFG$U.UYxyZhubItWX6868qFTeaT56XPLAGhsW./CLdPlD6Gwa/XBBklDF7HlmqofSFKl/xuwez0n72osgvfU0vxP0:18916:0:99999:7:::
# After
envader:$6$9YgzMkIXKldUPCFG$U.UYxyZhubItWX6868qFTeaT56XPLAGhsW./CLdPlD6Gwa/XBBklDF7HlmqofSFKl/xuwez0n72osgvfU0vxP0:18916:5:30:7:::
```

パスワードエージング未設定時、**:0:99999**（無期限）であった箇所が、**:5:30**に変更されている

## suコマンドとsudoコマンドの違い

### **suコマンド**

- **用途**: **su**（substitute user）コマンドは、他のユーザー（主に**root**）の権限で新しいシェルセッションを開始するために使われる
- **動作**: **su** コマンドを実行すると、対象のユーザー（例えば**root**）のパスワードを求められる。パスワードを正しく入力すると、そのユーザーの権限で新しいシェルセッションが開始される
- **例**:
    - **su（引数なし）**- **root**ユーザーに切り替えるにゃん。
    - **su envaderuser** - **envaderuser**ユーザーに切り替えるにゃん。

### **sudoコマンド**

- **用途**: **sudo**（superuser do）コマンドは、特定のコマンドを**root**ユーザーの権限で実行するために使われる
- **動作**: **sudo** コマンドを使用すると、現在のユーザーのパスワードを求められるにゃん（**root**のパスワードではない）。このユーザーが**sudoers**ファイルにて**sudo**実行の権限を持っていれば、指定したコマンドが**root**権限で実行される。
- **例**:
    - **sudo apt update** - **root**権限で**apt update**コマンドを実行する。

### **まとめ**

- **su**は、他のユーザー（通常は**root**）として新しいシェルセッションを開始する
（ユーザーを完全に切り替え、そのユーザーの環境で操作する）
- **sudo**は、現在のユーザー環境を維持しつつ、一時的に**root**権限で特定のコマンドのみを高い権限で実行する
- **su**は対象のユーザーのパスワードが必要だが、**sudo**は実行するユーザー自身のパスワードを使用する

| 特徴 | su | sudo |
| --- | --- | --- |
| ユーザー切替 | 完全に別のユーザーに切り替わる | 現ユーザーのまま特定コマンドを実行 |
| パスワード | 対象ユーザー（rootなど）のパスワード | 実行ユーザー自身のパスワード |
| 環境 | 対象ユーザーの環境になる | 現在のユーザー環境を保持 |
| 使用例 | su、su - ユーザー名 | sudo コマンド |
| 適用範囲 | 新しいシェルセッション全体 | 一時的に特定のコマンドに適用 |

## ****chownコマンド****

**chown**（change owner）はファイルの所有者（owner）を変更するためのコマンド

**chown**コマンドを実行するにはroot権限が必要。

```bash
ls -l
-rw-r--r--  1 envader redavne    0 May 17 05:07 sample.txt

# sudoコマンドを使うと一時的にroot権限が付与される。
# 書式: chown [新たなユーザー名] [変更するファイル名]
sudo chown deenvar sample.txt
-rw-r--r--  1 deenvar redavne    0 May 17 05:07 sample.txt
```

また、所有者と所有グループを同時に変更することも可能

```bash
ls -l
-rw-r--r--  1 envader redavne    0 May 17 05:07 sample.txt

# 新たなユーザー名とグループ名を:（コロン）で繋いで指定する
sudo chown deenvar:envader sample.txt
-rw-r--r--  1 deenvar envader    0 May 17 05:07 sample.txt
```

ディレクトリ配下のファイルやディレクトリの所有者を変更する場合は、**-R**（--recursive）オプションを指定

## **chgrpコマンド**

**chgrp**（change group）はファイルの所有グループを変更するためのコマンド。**chgrp**コマンドは一般ユーザーでも実行できるが、その場合に設定可能なグループはそのユーザーが属しているグループに限定される。それ以外のグループを指定する場合はroot権限が必要となる。

```bash

ls -l
-rw-r--r--  1 envader redavne    0 May 17 05:07 sample.txt

# 書式: chgrp [新たなグループ名] [変更するファイル名]
chgrp envader sample.txt
-rw-r--r--  1 envader envader    0 May 17 05:07 sample.txt
```

なお、ディレクトリの所有グループを変更する場合は**-R**オプションを指定する。

## umaskコマンド

ファイルやディレクトリが作成されるとき、そのデフォルトのパーミッションはumask値を用いて決定される。**umask**（user file-creation mode mask）はumask値（ファイルが作成されたときにデフォルトで付与されるパーミッション）を変更・確認するためのコマンド。

現在のumask値を確認

```bash
umask
022
```

上の例では3桁で表示されているが、4桁で表示されることもある。その場合は下3桁が**r** **w** **x**が設定される部分に該当。umask値からパーミッションを計算する場合、ファイルの場合は **666** から、ディレクトリの場合は **777** からumask値を引く。この例のようにumask値が022の場合のパーミッションは、ファイルでは「644」（ = 666-022）、ディレクトリでは「755」（ = 777-022）になる。

次に、umask値を変更する。

```bash
umask 002
touch maskfile
mkdir mask_dir
ls -l
drwxrwxr-x  2 envader redavne 4.0K May 17 05:51 mask_dir
-rw-rw-r--  1 envader redavne    0 May 17 05:51 maskfile
```

umask値を「022」から「002」に変更したことで、新たに作成したファイル（**maskfile**）のパーミッションが「664」（ = 666-002）に、ディレクトリ（**mask_dir**）は「775」（ = 777-002）になっています。

### **特殊なパーミッション （SUID／SGID／スティッキービット）**

特殊なパーミッションには**SUID** ・**SGID** ・**スティッキービット** の３種類がある。

- 特殊なパーミッションそれぞれの説明
    
    > **s: SUID（Set User ID）とSGID（Set Group ID）**
    > 
    > - **SUID**（Set User ID）
    >     - この権限が設定された実行ファイルは、ファイルの所有者の権限で実行される
    >     - 例えば、**root**ユーザーが所有するファイルにSUIDが設定されていると、他のユーザーがそのファイルを実行する時、**root**の権限で実行される
    > - **SGID**（Set Group ID）
    >     - この権限が設定された実行ファイルは、ファイルのグループの権限で実行される
    >     - ディレクトリにSGIDが設定されている場合、そのディレクトリ内で作成される新しいファイルやサブディレクトリは、親ディレクトリと同じグループに属する
    > 
    > ### **t: スティッキービット**
    > 
    > - スティッキービットは、主にディレクトリに設定される特別な権限
    > - スティッキービットが設定されたディレクトリでは、ファイルの削除や名前変更を、そのファイルの所有者またはディレクトリの所有者、あるいは**root**ユーザーのみが行える
    > - 例えば、多くのユーザーがアクセスする**/tmp**ディレクトリには通常、スティッキービットが設定されていて、ユーザーが互いのファイルを誤って削除しないように保護されている
    > - スティッキービットが設定されたディレクトリのパーミッション表示では、最後の**x**（他のユーザーの実行権限）が**t**に置き換わる。これは、ディレクトリのパーミッションに対する変更であり、その他のユーザーのパーミッションそのものを変更するわけではない
- SUID / SGIDの例
    
    ユーザーがパスワードを変更する場合を考えてみる。**passwd**コマンドでパスワードを変更すると、**/etc/passwd**ファイルの該当箇所が書き換えられる。
    
    まずは**/etc/passwd**ファイルを確認してみる。
    
    ```bash
    ls -l /etc/passwd
    -rw-r--r-- 1 root root 1837 May 15 04:36 /etc/passwd
    ```
    
    所有者はrootユーザーになっており、他のユーザーやグループに書き込み権限は与えられていない。しかし、**/etc/passwd**ファイルは一般ユーザーにでも更新可能となっている。
    
    **passwd**コマンドを確認してみる。
    
    ```bash
    which passwd
    /usr/bin/passwd
    $ ls -l /usr/bin/passwd
    -rwsr-xr-x 1 root root 68208 Jul 15  2021 /usr/bin/passwd
    ```
    
    所有者の実行権限が**s**になってる。これを**SUID** （Set User ID）と言う。SUIDが設定されたファイルは、ファイル所有者の権限で実行されう。つまり、今回の例の場合は一般ユーザーとして実行したとしても、実際はrootユーザーの権限で実行されている。これがグループに付与されている場合は**SGID** （Set Group ID）と言う。
    
    実際にSUID・SGIDを設定してみる。
    
    ```bash
    
    ls -l
    -rw-r--r--  1 envader redavne    0 May 17 05:07 sample.txt
    
    # 記号でSUIDを設定します。
    sudo chmod u+s sample.txt
    ls -l
    -rwSr--r--  1 envader redavne    0 May 17 05:58 sample.txt
    
    # 数字で設定する場合は、4000を指定します。
    sudo chmod 4744 sample.txt
    ls -l
    -rwsr--r--  1 envader redavne    0 May 17 05:58 sample.txt
    ---------------------------------------------------------------
    ls -l
    -rw-r--r--  1 envader redavne    0 May 17 05:07 sample.txt
    
    # 記号でSGIDを設定します。
    sudo chmod g+s sample.txt
    ls -l
    -rw-r-Sr--  1 envader redavne    0 May 17 05:59 sample.txt
    
    # 数字で設定する場合は、2000を指定します。
    sudo chmod 2674 sample.txt
    ls -l
    -rw-rwsr--  1 envader redavne    0 May 17 05:59 sample.txt
    
    ```
    
    SUID・SGIDを設定する際に、予め所有者や所有グループに実行権限**x**がある場合には小文字の**s**、ない場合には大文字の**S**が付与される。
    
    次に、**/tmp**ディレクトリを確認してみる。
    
    ```bash
    ls -l /tmp
    drwxrwxrwt 109 root root  20K May 17 02:52 tmp
    ```
    
- スティッキービットの例
    - その他のユーザーの実行権限が**t**になっている。これを**スティッキービット（sticky bit）** と言う
    - スティッキービットはディレクトリに設定されるパーミッション
    - スティッキービットが設定されたディレクトリには、書き込み権限はあるが、自分以外のユーザーが所有者となっているファイルを削除することはできない
    - **/tmp**ディレクトリでは、全てのユーザーに書き込み権限が付与されているが、スティッキービットが設定されていることで、**/tmp**配下に自分以外のユーザーが作成したファイルは削除できない
    
    実際にスティッキービットを設定してみる。まずはディレクトリを作成する。
    
    ```bash
    mkdir sample_dir
    ls -ld sample_dir
    drwxr-xr-x  2 envader redavne 4096 Jul 25 12:34 sample_dir
    ```
    
    次に、スティッキービットを設定
    
    ```bash
    # 記号でスティッキービットを設定
    sudo chmod o+t sample_dir
    ls -ld sample_dir
    drwxr-xr-t  2 envader redavne 4096 Jul 25 12:34 sample_dir
    
    # 数字で設定する場合は、1000を指定
    sudo chmod 1755 sample_dir
    ls -ld sample_dir
    drwxr-xr-t  2 envader redavne 4096 Jul 25 12:34 sample_dir
    ```
    
    この例では、まず新しいディレクトリ **sample_dir** を作成。デフォルトでは、ディレクトリのパーミッションは **drwxr-xr-x** となる。次に、**chmod o+t sample_dir** コマンドでスティッキービットを設定。その結果、ディレクトリのパーミッションは **drwxr-xr-t** となる。ここで **t** はスティッキービットを表す。
    
    最後に、 **chmod 1755 sample_dir** コマンドで数値を使用してスティッキービットを設定する。ここで、 **1** はスティッキービットを表し、**755** はそれぞれ所有者、グループ、その他のユーザーのパーミッションを表していうｒ。このコマンドを実行した後も、ディレクトリのパーミッションは **drwxr-xr-t** となり、スティッキービットが設定されていることが確認できる。
