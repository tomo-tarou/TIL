## Linuxとは
- Linuxは、本来Linux系OSの核であるLinuxカーネルを指す言葉である。カーネルとはOSの中核を担うプログラムであり、ハードウェアの資源管理やソフトウェアとハードウェアを繋ぐ役割を担う。
- カーネルがソフトウェアとハードウェアの橋渡しとなることでカーネルがソフトウェアの利用に合わせてハードウェアに命令を出すことができ、これによりソフトウェアは直接ハードウェアに対して命令をしなくてもすむようになっている。
- カーネルはOS(コンピュータを制御するソフトウェア)の核である一方でカーネル単体ではOSを動作させることは出来ない。OSを動かすためにはカーネル以外にもさまざまなソフトウェアが必要。そして、Linuxカーネルとその他のソフトウェアを組み合わせたものがLinuxディストリビューションであり広い意味でのLinuxになります。
- Linuxディストリビューションは大きく分けてDebian系、Red Hat系、Slackware系の三つが存在する。そして、これら三つの系統からさらに派生版が生まれており、三つの系統以外にも独立した系統のディストリビューションも存在している。

[Linuxのディストリビューションについて（ubuntu, centos）](https://envader.plus/article/7)

### **ディレクトリにまつわる用語**

| 用語 | 説明 |
| --- | --- |
| ディレクトリ | Linuxにおけるフォルダのこと |
| カレントディレクトリ | 今自分がいるディレクトリ |
| ルートディレクトリ | 一番上の階層のディレクトリ |
| ホームディレクトリ | ユーザーがログインした時に最初に開くディレクトリ |

パス(path)とは**ファイルのある場所までの道のり** を表すものです。“path”は「道・道のり・経路」といった意味がある英単語

| 記号 | 説明 |
| --- | --- |
| . | カレントディレクトリ(現在いるディレクトリのことです) |
| .. | 一つ上の階層(ディレクトリ) |
| / | ルートディレクトリ |
| ~ | ホームディレクトリ |
| - | ひとつ前にいたディレクトリ |

絶対パスは、**`/`(ルートディレクトリ)を起点にした、ファイルの場所を示すパス** 。

（絶対パスを「フルパス(full path)」ということもある。）

## cdコマンド
cd （change directoryの略）はディレクトリ間を移動する際に使用するコマンド。現在作業をしているディレクトリ（カレントディレクトリ）から、別のディレクトリに移動するときに使用。
**-（ハイフン）** を指定すると一つ前にいたディレクトリに移動することができる。

## lsコマンド
ls（listの略だが、list segmentsの略説もある）はディレクトリの中にあるファイルやディレクトリ等を確認するために使用するコマンド

### 主なオプション
| -a | 隠しファイルを含む全てのファイル(ディレクトリ)を表示する |
| --- | --- |
| -A | 隠しファイルを含む全てのファイル(ディレクトリ)のファイル名のみを表示する |
| -l | ファイルの種類や所有者・所有グループなどのファイル(ディレクトリ)の詳細を表示する |
| -i | inode番号も表示する |

### inode番号とは

### **`i` オプション**

- **`i`** オプションは、**`ls`**コマンド実行時に各ファイルやディレクトリのinode番号も一緒に表示するオプションです。
- **inode番号**:
    - inode番号は、LinuxやUnix系オペレーティングシステムにおいて、ファイルシステムが各ファイルやディレクトリを識別するために使用するユニークな番号
    - inodeにはファイルのメタデータ（サイズ、作成日時、所有者、パーミッションなど）が保存されているが、ファイル名やディレクトリ名は含まれない。
- 使用シーン（シチュエーション）
    1. **ファイルシステムのトラブルシューティング**:
        - inode番号を使って、ファイルシステムの問題を診断する際に役立つ。特にファイルシステムの破損やエラーが疑われる時に、inode番号を調べることで問題の原因を特定しやすくなる
    2. **ハードリンクの確認**:
        - 同じinode番号を持つ複数のファイル名（ハードリンク）が存在する場合、**`ls -i`**を使用してそれらが同じファイルを指しているかどうかを確認できる
    3. **ファイルの重複検出**:
        - 大量のファイルがある場合、**`ls -i`** コマンドを使用してinode番号を確認し、同じinode番号を持つファイルが重複していないかチェックできる
    4. **バックアップや復元プロセス**:
        - ファイルシステムのバックアップや復元を行う際、inode番号を参照して正しいファイルがバックアップや復元されているかを確認するのに役立ちます。
    
    これらの用途は、主にシステム管理者やアドバンスドユーザーがファイルシステムの深いレベルで作業を行う際に特に重要になりますにゃん。通常の日々の使用ではあまり使われることはないかもしれませんが、特定の状況や問題解決には非常に役立つコマンド
    

### ハードリンクとは
- ハードリンクは、ファイルシステム上の同じデータを指す異なるファイル名である。これらはすべて同じinode番号を共有する
- これにより、複数のファイル名が実際には同じ物理的なデータを指していることになる
- ハードリンクを作成すると、異なる名前で同じファイルにアクセスできますが、ディスク上のスペースは追加で消費されない
- いずれかのハードリンクを変更または削除しても、他のハードリンクや元のファイルには影響しない。ファイルシステムは最後のリンクが削除されるまでデータを保持します。

**例：**ファイル **`file1.txt`** があり、それに **`file2.txt`** というハードリンクを作成した場合、**`file1.txt`** と **`file2.txt`** は同じinode番号を持ち、どちらも同じファイルの内容を指す。この特性は、ファイルの整理、バックアップ、データ管理などで役立つが、同時に複数のファイル名が同じ内容を指していることを認識しておく必要がある

### **ハードリンクの特性**
- **同じinode番号**: ハードリンクされたファイルは、同じinode番号を持つ。これは、同じ物理的なデータを指していることを意味する。
- **異なるファイル名**: 同じファイル内容が異なる名前で存在することができるが、これらはファイルシステム上では同一のファイルとして扱われる。

### **ハードリンクでない場合**
- 異なるinode番号を持つファイルは、ハードリンクではない。これらは別々のファイルとして存在し、それぞれ独立した内容を持つ。
- 例えば、ファイルをコピーして新しい名前を付けた場合、コピーされたファイルは新しいinode番号を持ち、元のファイルとは異なるものになる。

ハードリンクは同じデータを指す複数のエントリを作成するためのメカニズムだが、単にファイル名が異なるだけではハードリンクとは言えない。ハードリンクかどうかはinode番号によって判断される。

## catコマンド
catはファイルの中身を見るコマンドで、「concatenate」（つなげる・連結する）の略

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -s | 連続したスペースやタブを1行にして表示する |
| -n | 行番号をつけて表示する |
| -A | 非表示文字も含めてすべて表示する |
| -E | 最終行に$を表示する |

```
# sample1.txtとsample2.txtの中身を連結して表示します。
cat sample1.txt sample2.txt

# sample1.txtとsample2.txtの中身を連結させたものをsample3.txtという新規ファイルに出力します。
cat sample1.txt sample2.txt > sample3.txt
```

ファイルの中身を逆順で表示する**`tac`**というコマンドもある

```
# sample.txtというテキストファイルを作成します。
vi sample.txt
==========
Google
Apple
Facebook
Amazon
==========

# tacコマンドでsample.txtを出力します。
tac sample.txt
Amazon
Facebook
Apple
Google
```

## nlコマンド
nl(number line)は行頭に行番号を振って出力するコマンド。

```bash
nl sample.txt
	1 Google
	2 Apple
	3 Facebook
	4 Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -b | 指定されたタイプで行番号を振る |
| -h | -bと同様の指定したタイプでヘッダ(header)に行番号を振る |
| -f | -bと同様の指定したタイプでフッタ(footer)に行番号を振る |

### **タイプ**

オプションにはタイプを指定できます。

| タイプ | 説明 |
| --- | --- |
| a | すべての行 |
| t | 空行でないすべての行 |
| p | 正規表現にマッチしたテキストを含む行 |

## fmtコマンド
fmt(format)はファイルを整形して出力するコマンド

```bash
# オプションのない場合は全て横並びになります。
fmt sample.txt
Google Apple Facebook Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -c | インデントを保持したまま整形する |
| -s | 長い行を複数行に分割する |
| -t | タグ(a.や 1.など)付きの段落として整形する |
| -w | 表示幅を指定する |

## wcコマンド
wc(word count)は文字数をカウントしたり、ファイルサイズを出力したりするためのコマンド

```
wc test_file
15      15     105 test_file
```

オプションなしの場合は[行数]・[単語数]・[文字数]・[ファイル名]という順序で表示されます。

### **主なオプション**
| オプション | 説明 |
| --- | --- |
| -c | バイト数を表示する |
| -m | 文字数を表示する |
| -l | 改行数を表示する |
| -w | 単語数を表示する |
| -L | 最長の行を表示する |

## cutコマンド
cutはファイル内のテキストを部分的に切り取って出力するためのコマンド

```bash
# stationery.txtというファイルを作成します。
vi stationery.txt
=========
pencil
stapler
paper clip
eraser
=========

# 区切り文字にスペースを指定し、1つ目の項目のみを表示します。
# 3行目は”paper”だけが出力されます。
cut -d " " -f 1 stationery.txt
pencil
stapler
paper
eraser
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -b | 切り取るバイト数を指定する |
| -c | 指定列の文字のみを切り出す |
| -d | 区切り文字(delimiter)を指定する (デフォルトではカンマです) |
| -f | 区切られた項目のうち、表示する項目を指定する |

## prコマンド

pr(print)は印刷に適した形式にファイルを整形するコマンド

```bash
pr -2 sample.txt
Google				    Facebook
Apple				    Amazon
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -d | 行間に空行を差し込む |
| -数値 | 指定した数値の列数に整形する |

## mvコマンド

mvはディレクトリやファイルを別のディレクトリへ移動したり、ディレクトリ名やファイル名を変更する際に使用するコマンド

```bash
# 使い方
mv [オプション] [移動させたいディレクトリ(またはファイル)名] [移動先のディレクトリ名]
```

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -f | 移動先に同名のファイルがある場合、強制的に移動（上書き）されます。 |
| -i | 移動先に同名のファイルがある場合、確認メッセージが表示されます。 |
| -b | 移動により上書き（削除）されるファイルのバックアップを作成します。 |
| -n | 移動先に同名のディレクトリ（またはファイル）がある場合は、処理を実行しません。 |
| -v | 移動処理を行う際の詳細情報を表示します。 |

mvコマンドはディレクトリやファイルの中身は変更せず、名前だけを変更することもできる。 その際、新しく指定するディレクトリ名(またはファイル名)は、そのディレクトリに存在しない名前でなければならない。既存の名前を指定してしまうと、そのディレクトリやファイルが対象ディレクトリ・ファイルの内容で上書きされてしまうので注意が必要。

```bash

# ファイル名をファイル1からファイル2へ変更します。
mv [ファイル1] [ファイル2]
```

ファイルを任意のディレクトリに移動する場合には、移動先のディレクトリ名の後ろに/.をつけることで、より安全に作業を行える。この/.の指定により、移動先がディレクトリであることを明示的に示すことができ、存在しないディレクトリ名が指定された場合に、予期しないリネーム操作を防ぐことができる。 この/.には「ディレクトリ直下の」という意味があります。もし/.を付けずに上記のコマンドを指示し、且つhogehogeディレクトリが存在していなかった場合、hoge.txtファイルはhogehogeというファイルにリネームされるという挙動をとる。

```bash

#hoge.txtをhogehogeディレクトリに移動
mv hoge.txt hogehoge/.
```

## cpコマンド
cpは既存のファイルを複製する（コピー）際に使用するコマンド

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -i | コピーによって上書きされるファイルがある場合、確認メッセージを表示 |
| -v | コピーの実行内容を表示 |
| -n | コピー先に既に同名のファイルが存在する場合、処理を中断する。 |
| -f | コピー先に同名のファイルが存在していても、強制的にコピー（上書き）を実行。 |
| -b | コピー（上書き）時にバックアップファイルが作成される |
| -r | ディレクトリ内を再帰的にコピーする。 |
| -p | 所有者・属性・更新日時など元ファイルのものを保持する。 |

### **再帰的にコピーする**

- -rオプションを使用してディレクトリをコピーすると、その中にある全ての子ディレクトリやファイルを含めてコピーすることが出来ます。

```bash

cp -r [コピー元ディレクトリ] [コピー先ディレクトリ]
```

- 「再帰的」は、ある条件が満たされた場合に、その処理が自分自身を呼び出し繰り返すことを指す。cpコマンドの場合、-rオプションを使用すると、指定したディレクトリ内のすべてのサブディレクトリやファイルをコピーすることが可能になる。このとき、コピー処理は各ディレクトリやファイルに対して一つずつ実行され、それぞれの処理が終わるごとに、次に処理対象となる要素がコピー対象であるかどうかを判断する。コピー対象であると判断された場合、処理は再度自分自身を呼び出し、これを繰り返すことで全ての要素をコピーする。このような処理のことを「再帰的」と言う。

- cp: -r not specified; omitting directory 'myapp/'

- ディレクトリをコピーする際に -r をつけ忘れたことによるエラー
  - specify 指定する
  - ommit 省略

[Linuxコマンド [cd/ls/cat等]](https://envader.plus/course/1/scenario/1001)

## touchコマンド

touchとは、空のファイルを新規作成したり、ファイルのタイムスタンプを更新したりするためのコマンド。タイムスタンプとは、ファイルの**最終更新日**を表すもの。

### **主なオプション**

| オプション | 説明 |
| --- | --- |
| -t | [[CC]YY]MMDDhhmm[.ss]の書式に則り、タイムスタンプを指定した日時に更新 |
| -d | 日時を文字列で指定して、タイムスタンプを更新 |
| -c | 存在しないファイル名を指定しても、空の新規ファイルを作成しない |
| -r | 指定した他のファイルのタイムスタンプに合わせて更新される |
| -m | ctimeのみを変更される |

-tオプションでは、過去の時間も指定できる

-mオプションで変更されるctimeとは、inode変更日時のことを指す

それに対して、何も指定しない場合は、最終更新日時(mtime)と最終アクセス日時(atime)が更新される。

c**は "change"（変更）の略で、ファイルのメタデータやinode情報が最後に変更された日時を指す「ctime」を表している。**

m **は "modification"（変更）の略で、ファイルの内容が最後に変更された日時を指す「mtime」を表している。**

a **は "access"（アクセス）の略で、ファイルが最後に読まれた日時を指す「atime」を表している。**

## fileコマンド

ファイルの種類を識別するときに使うコマンド。

ファイル名を見ただけではテキストファイルなのかバイナリファイルなのか判断できないが、fileコマンドを使用することでファイルの中身を調べることができる。

- ファイルの種類
    
    コンピュータでは、テキストファイル・画像ファイル・音声ファイルなど色々な種類のファイルを扱うが、これらは大きく2種類に分けることができる。
    
    - **テキストファイル：中身を開いたときに文字だけで構成されるファイル**
    - **バイナリファイル：テキストファイル以外の人間が読むことのできないファイル**
    
    **拡張子とファイルシグネチャの違い**
    
    - ファイル中身を判断するものとして、拡張子（.txt）と**ファイルシグネチャがある。**
    - 拡張子は、お馴染みのようにファイルの種類を識別するためにファイル名の後につけられたドットから始まる文字列のこと。例えば、「hogehoge.txt」というファイルの場合、「**.txt**」がテキストファイルを表す拡張子になる。
    - 拡張子はOSが、拡張子をもとに起動するプログラムを変更したり、人間が一目見てファイルの種類を識別するために付けられる。つまり、拡張子はファイルの種類を人間や起動するアプリケーションが判定するためのものであり、実際のファイルの中身とは別物である。そこで、ファイルシグネチャが存在する。
    - ファイルシグネチャとは、各ファイルの先頭数バイトの決められた文字列のこと。ファイルフォーマット・マジックナンバーと呼ぶこともある。OSは、ファイルの先頭数バイトを確認することにより（実際の）ファイルの種類を判別する。
    

### **基本的な使い方**

```bash
file ファイル名

# 例
file test.txt
test.txt: Unicode text, UTF-8 text, with no line terminators

file sample.jpeg
sample.jpeg: JPEG image data, Exif standard: [TIFF image data, big-endian, direntries=6, orientation=upper-left, xresolution=86, yresolution=94, resolutionunit=2], baseline, precision 8, 4032x3024, components 3
```

fileコマンドではファイルの内容をテストし、ファイルの種類を特定している。

テスト結果から下記いずれかの内容を表示する。

- **text：テキストファイル**
- **executable：実行可能ファイル**
- **data：それ以外のファイル（通常はバイナリファイル、または表示不能なファイル）**

### **複数のファイルを同時に指定する**

fileコマンドの後に複数のファイルを同時に指定することもできる。

```bash
file ファイル名1 ファイル名2

# 例
file test.txt index.html
test.txt:   Unicode text, UTF-8 text, with no line terminators
index.html: HTML document text, ASCII text
```

### **圧縮されているファイルを調べる**

「-**z**」オプションで、圧縮されているファイルの元の形式を調べることができる。

```bash
file -z ファイル名

# 例1：「-z」オプションがない場合（ファイル形式がわからない）
file test.txt.gz
test.txt.gz: gzip compressed data, was "test.txt", last modified: Sat Jan  8 00:36:35 2022, from Unix, truncated

# 例2：「-z」オプションがある場合（テキストファイルとわかる）
file -z test.txt.gz
test.txt.gz: Unicode text, UTF-8 text, with no line terminators (gzip compressed data, was "test.txt", last modified: Sat Jan  8 00:36:35 2022, from Unix)

```

### **主なオプション**

| オプション | 意味 |
| --- | --- |
| -b | 出力行の最初にファイル名を表示しない（簡易モード） |
| -f | 調べるファイルの一覧を指定する |
| -L | シンボリックリンクの参照先を調べる |
| -N | 出力を整列するためのファイル名への空白の追加を行わない |
| -n | １つのファイルをチェックするごとに標準出力に出力する |

[data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2725%27%20height=%2725%27/%3e](data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2725%27%20height=%2725%27/%3e)

[Linuxコマンド [cd/ls/cat等]](https://envader.plus/course/1/scenario/1001)

[Linuxコマンド [touch編]](https://envader.plus/course/1/scenario/1005)

[Linuxコマンド [file編]](https://envader.plus/course/1/scenario/1046)

[代表的な拡張子の一覧【とはサーチ】](https://www.toha-search.com/pc/kakutyousi-list.htm)

## プロセスとは

プロセスとは、メモリ上にある実行中のひとつひとつのプログラムのこと。プロセスはコンピュータリソースを消費する。ここでいうコンピュータリソースとは、CPUやメモリなどを指す。限られたリソースをどのように配分するのかは非常に重要なことである。そこでプロセス管理が必要になってくる。

### **プロセスの状態**

プロセスには、さまざまな”状態”があります。

| 状態 | 説明 |
| --- | --- |
| 生成(開始) | 新たにプロセスが生成された状態 |
| 実行可能 | CPUが割り当てられるのを待っている状態 / ※ 実行中のプロセスが他のプロセスに割り込まれた時もこの状態になる |
| 実行中 | プロセスにCPUを割り当てられた状態 |
| 待機 | プロセスの読み書き処理待ち状態 / ※ このときCPUの処理は必要なく、読み書きが終わると実行可能状態になる |
| 終了 | プロセスの処理が完了、あるいは中止した状態 |

## **プロセスのジョブ**

ジョブとはひとつ以上のプログラムの実行単位のこと。**コマンドを入力して実行**するとひとつのジョブとしてカウントされるので、コマンドがひとつでもジョブになる。

ジョブには二種類存在する。

**フォアグラウンドジョブ：** シェルの画面内で実行される。普通にターミナルでコマンドを実行する場合フォアグラウンドジョブになる。表側で実行されるので処理の完了を待つ必要がある。

**バックグラウンドジョブ：** シェルの画面外で動作する。処理は実行されているが、ユーザーの操作対象ではない。裏側で実行されるので処理の完了を待つ必要がない。

バックグラウンドで実行

```bash
コマンド &
```

実行中のジョブを表示

```bash
jobs
```

バックグラウンドジョブをフォアグラウンドに戻したいとき

```bash
fg %ジョブID
```

フォアグラウンドジョブをバックグラウンドジョブにしたいとき

```bash
bg %ジョブID
```

## プロセスとジョブの違い

プロセスは、実行中のプログラムのインスタンス（実体のこと）で、オペレーティングシステムからメモリ空間、プロセスID、必要なリソースなどを割り当てられている。プロセスはシステムリソースを利用して、実際にタスクを実行する。

一方で、ジョブとは、ひとつまたは複数の関連するプロセスの集まりで、より大きなタスクや一連のタスクを実行するための単位。たとえば、ユーザーがある目的のために連続して実行するプログラム群をジョブと呼ぶ。

簡単に言うと、プロセスは個々の実行中のプログラムで、ジョブはそれらプロセスが集まって一つの目的を達成するための単位と考えると理解しやすい。例えば、印刷ジョブは複数のプロセス（データを処理するプロセス、プリンタに送信するプロセスなど）を含むことがある。

プロセスはシステムの動的な活動の基本単位で、ジョブはユーザーが指定したタスクの実行単位、という感じ

## killコマンド・psコマンド

killは、プロセスを終了させるためのコマンド

使用用途

- **時間のかかるコマンドを誤って実行してしまった**
- **ゾンビプロセス(実態はないのにプロセステーブルに存在するプロセス)に対処**

## **基本的な使い方**

psコマンドでプロセスIDを確認する

```bash
ps aux
```

プロセスIDとシグナルを指定して実行

```bash
kill シグナル番号 PID
```

コマンドを強制終了したい場合

```bash
kill -9 PID
```

### **シグナルについて**

プロセス間の通信をするための信号で、プロセスの状態を遷移することができる。

プロセスはスーパーユーザーからのシグナルを受け取ることができる。

[プロセス管理 ｰ 1](https://envader.plus/course/15/scenario/1008)

[プロセス管理 ｰ 2](https://envader.plus/course/15/scenario/1009)

## uname****コマンド****

カーネルやバージョンなどを確認するために使用するコマンド

### よく利用するオプション

unameコマンドのみではLinuxという情報以外何もわからないので、知りたい情報に合わせてオプションを指定します。今回はよく利用するオプションを紹介します。

| オプション | 説明 |
| --- | --- |
| -o | OSの名前を表示 |
| -v | カーネルのバージョンを表示 |
| -r | カーネルのリリース番号を表示 |
| -p | CPUの種類を表示 |
| -a | unameコマンドで確認できる全ての情報を表示 |

[バージョンの確認](https://envader.plus/course/15/scenario/1010)

## whichコマンド

whichは指定したコマンドのフルパスを表示してくれるコマンド

```bash
which ls
/bin/ls
```

/binに存在するlsコマンドが実行されていることが分かる。つまり、このフルパス（/bin/ls）を実行してもlsとだけ打って実行しても同じことであるということ。

また、コマンドがビルトインコマンドなのか、外部コマンドなのかも判定する。echoコマンドのパスを調べてみる。

```bash
which echo
echo: shell built-in command
```

「echoはシェルのビルトインコマンドです」と表示されている。

**ビルトインコマンド**とは、**シェルに組み込まれているコマンド**であるため、パスはない。それ以外のコマンドは**外部コマンド**といい、/binや/usr/binなどといったバイナリを格納するディレクトリに置かれている。

whichはファイルやパッケージの保存場所を調べるときなど、このあと紹介するtypeやwhereisに比べてかなり頻繁に使用する。

## typeコマンド

typeは、機能的にはほとんどwhichと同様

```bash
# findコマンドのフルパスを表示する
type find
find is /usr/bin/find
```

丁寧に「findのパスは/usr/bin/findです」と表示してくれるが、シンプルにパスのみを表示してくれるwhichの方がよく使われる。

## whereis****コマンド****

whereisはコマンドとその関連ファイルのフルパスを表示する。whichやtypeとの違いは、コマンドに関連するファイルのフルパスまで表示すること。ただし、あまり使用するケースは多くない。

```bash
whereis ls
ls: /usr/bin/ls /mnt/c/Program Files (x86)/Gow/bin/ls.exe /usr/share/man/man1/ls.1.gz
ユーザー名:~# whereis find
```

| オプション | 説明 |
| --- | --- |
| a | コマンドのエイリアス、フルパスを表示 |
| p | コマンドのフルパスを表示 |
| t | コマンドのエイリアスを表示 |

## コマンドサーチパスとは

コマンドサーチパス（PATH）は、シェルがコマンドの実行ファイルを探すために参照するディレクトリのリスト。これにより、ユーザーは実行ファイルのフルパスを指定せずにコマンドを実行できるようになる。実質的に、PATHはコマンドのショートカットを提供し、効率的にシステムを操作するために使われる**。**

- コマンドサーチパスを環境変数PATHに登録することを「パスを通す」と言う
- pathにコマンドのパスが登録されていることを「パスが通っている」と言う

## パスを通す

新たなパスを追加して他のディレクトリ上にあるコマンドを認識させること。

コマンドサーチパスを環境変数PATHに登録することを「パスを通す」と言う。環境変数PATHには複数のパスを登録可能。コマンドが実行されると環境変数PATHに登録されているディレクトリを順に検索し、コマンドが見つかれば実行する。パスが通っていないコマンドを実行するとエラーになる。

```bash
# 環境変数PATHを表示
echo $PATH
/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin

# export コマンドで新しくPATHを追加
export PATH=$PATH:/home/sample

# 環境変数PATHに/home/sampleが追加されている
echo $PATH
/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/home/sample

```

これで lsや cat のようにファイル名をコマンドラインで実行するだけで、/home/sample内のコマンドやシェルスクリプトを実行することができる。

### パスを通す時の注意点

- カレントディレクトリにはパスを通さない（セキュリティ的に問題が生じるため）
- カレントディレクトリのファイルを実行したい場合にはファイル名の先頭に./をつけて実行することになっている
- パスを通す際は安全なディレクトリに絞って設定することが大切

## ターミナルとパスの違い

ターミナルは、ユーザーがコマンドを入力し、システムと対話するためのインターフェイスを提供するアプリケーションのこと。昔の物理的な端末から派生した概念で、現在ではソフトウェアとして実装されたウィンドウやプログラムである。

シェルは、ユーザーからのコマンドを受け取り、それをオペレーティングシステムへと伝える役割を持つプログラム。シェルはコマンドラインインターフェイス（CLI）を提供し、ターミナルから入力されたコマンドに基づいて操作を行う。bashやzshなどが一般的なシェル。

要するに、ターミナルはコマンドを打つ場所であり、シェルはそのコマンドを解釈して実行するプログラムというわけである。両者は密接に連携していて、一般にはターミナルを開くとシェルが起動し、ユーザーのコマンド入力を待ち受ける状態になる。

## 実行ファイルとは

- 実行ファイルは、ほとんどの場合「バイナリファイル」のことを指す。（広義の解釈で、人間が読めるスクリプトファイル等も含み、それを実行可能なテキストファイルとすることもあるが、あまり一般的ではない。)
- 「バイナリファイル」はコンピュータが直接解釈し実行できる機械語の命令を含むファイル（0と1で構成されているので、人間は読む（解釈）できない）。Windowsでの .exe ファイルやLinuxでの実行可能なファイル（特定の権限が与えられたファイル）がこれに該当する。
- バイナリファイルの中でも多くのLinuxは実行ファイルの形式にELFというファイル形式のものを使用している。
- ELFとは、「Executable and Linkable Formats」の略で、主にUnix系のオペレーティングシステム（OS）で用いられる実行可能ファイル、オブジェクトファイル、共有ライブラリ、コアダンプのファイル形式のことを言う。多くのLinuxディストリビューションやUnix系OSでは、プログラムやライブラリなどのバイナリファイルの標準的な形式としてELFが採用されている。
- ELF形式は柔軟性があり、異なるプロセッサアーキテクチャやオペレーティングシステム間での移植性が高いため、幅広く利用されている。プログラムがコンパイルされると、その実行可能ファイルがELF形式で生成されることが多い。
- 実行権限の変更は、 **chmod** コマンドで行う
- **機械語**
    
    機械語は、コンピュータのプロセッサが直接理解できる命令セット。これはバイナリ形式（0と1の列）で表され、プロセッサによって直接実行される。
    
- **実行ファイルのプロセス**
    1. **読み込み**: 実行ファイル（バイナリファイル）は、記憶ディスクからコンピュータのメモリに読み込まれる。
    2. **解釈**: プロセッサは、実行ファイルの中のバイナリデータ（機械語命令）を読み取る。
    3. **実行**: プロセッサは読み取った命令を順番に実行。これにより、プログラムが動作する。
- **実行権限**
    
    実行ファイルには実行権限というものが存在する。実行権限とは、実行ファイルに対してすべてのユーザーが実行出来てしまうと、問題が発生するため設けられている。
    
    実行権限は パーミッションと呼ばれ、**ls -l** コマンドで確認することが可能。もしくは **ll** でも確認できる？
    
    ```bash
    ls -l
    total 1900
    -rwxr-xr-x 1 envader envader 1941911  9月 28 05:49 run1
    ```
    
- **パーミッションの確認方法**
    
    先頭に書いてあるこの **-rwxr-xr-x**文字は、
    
    先頭の一文字はファイルの種類を表示しています。
    
    | 種類 | 説明 |
    | --- | --- |
    | - | ファイル |
    | d | ディレクト |
    | l | シンボリック |
    
    -はファイルを表しています。
    
    dはディレクトリを表しています。
    
    lはシンボリックを表しています。
    
    | 種類 | 説明 |
    | --- | --- |
    | 2文字目から4文字目 | ファイルの所有者に対する権限 |
    | 5文字目から7文字目 | ファイルの所有グループに対する権限 |
    | l8文字目から10文字目 | その他に対する権限 |
    
    | 権限の種類 | 説明 |
    | --- | --- |
    | r | 読み取り権限 |
    | w | 書き込み権限 |
    | x | 実行権限 |
    
    ```jsx
    -rwxr-xr-x 1 envader envader 1941911  9月 28 05:49 run1
    ```
    
- 実行ファイルを実行するには？
    
    ```markup
    # 絶対パスを利用する場合
    (実行ファイルのパス)
    # 例
    /bin/ls
    /usr/bin/whoami
    ```
    
    ```markup
    # 現在いるディレクトリに目的の実行ファイルがある場合
    ./(ファイル名)
    # 例
    ./a.out
    ./main
    ```
    
- 実行ファイルを実行してみて何か問題がある時
    
    下記を疑ってみる
    
    - **ELFファイルなのか**
    - **実行権限は持っているのか**
    - **パスは適切か**

## chmodコマンド

実行権限の変更を行うコマンド

```bash
chmod 変更対象 変更方法 変更内容 対象ファイル
```

| 変更対象 | 説明 |
| --- | --- |
| u | ユーザー |
| g | グループ |
| o | その他 |
| a | 全員 |

| 変更方法 | 説明 |
| --- | --- |
| ＝ | 指定した権限のみを与える |
| ＋ | 指定した権限を追加する |
| ー | 指定した権限を剥奪する |

| 権限の種類 | 説明 |
| --- | --- |
| r | 読み取り権限 |
| w | 書き込み権限 |
| x | 実行権限 |

所有グループに書き込み権限を与えたい場合は

```bash
#run1は対象ファイル名を指す
chmod g+w run1
```

とすることで与えることができます。

複数指定することも可能です。

```bash
chmod o+rw run1
chmod go+w run1
```
